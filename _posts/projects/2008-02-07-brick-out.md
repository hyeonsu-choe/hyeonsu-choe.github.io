---
title: 벽돌깨기
description: Windows 환경에서 C, Win32 API를 활용하여 만든 간단한 벽돌 깨기 게임
author: hyeonsu-choe
date: 2008-02-07 12:48 +0900
last_modified_at: 2025-10-28 20:05 +0900
categories: [Projects, Windows]
tags: [personal, win32, c]
toc: true
pin: false
render_with_liquid: false
image:
  path: /assets/img/projects/brick_out/block1.jpg
  # lqip: 
  alt: Gameplay screenshot of 벽돌깨기
---

| 구분 | 내용 |
|:----|:----|
|플랫폼|Windows|
|개발 도구 및 사용 언어|MS Visual Studio 2005, C, Win32 API|
|개발 기간| 2008년 3월 ~ 2008년 3월 |

## 1. 프로그램 소개

마우스 이용해 화면 하단에 위치한 바를 움직여 날아오는 공을 튕겨 내어 화면 상단에 위치한 벽돌들을 부수는 게임.

제대후 Win32 API 공부 겸 연습 삼아 만들었던다. 

벽돌들을 제한 시간내에 모두 부수면 다음 스테이지로 이동하며, 제한 시간이 만료 되거나 공이 화면 최하단으로 떨어질 경우 게임 오버가 된다.

### 게임 화면

---

![벽돌 깨기 스크린샷 1](/assets/img/projects/brick_out/block1.jpg)  


### 게임 오버 화면

---

![벽돌 깨기 스크린샷 2](/assets/img/projects/brick_out/block2.jpg)  



## 2. 프로그램 구조 개요

### 블록의 자료 구조와 배치

---

블록의 자료구조는 다음과 같다.

```c
#define nBlock 15 //블록 개수
typedef struct {
int left;
int top;
int right
int bottom;
BOOL brake;
}generate;
generate Block[nBlock]; //블록 구조체 nBlock 만큼 생성
```

블록을 다루는데 있어 배열 Block 하나만을 사용하기 위해 스테이지에 따라 그 원소 값을 변경하면서 재사용 한다.

```c
//블록 초기 위치 설정
int i, height = 1, width =1;

 switch(stage){

 case 1: //스테이지 1에서의 블록 배치
 for( i = 0 ,height = 1, width =1; i < nBlock; i++) {
   //이미지 시작 좌표 + (블록 가로 사이즈 * 블록 개수)

  //블록 다음행으로 개행, 1열 부터 다시 시작
   if(i%5 == 0) {height++; width = 1; }
   Block[i].left = ((cl.right/2) - (80*3)) + (80*width); //블록 x 좌표
   Block[i].right = (Block[i].left)+80; //블록 길이 (블록 시작 위치에서 + 하는 수치 만큼)
   Block[i].top = (cl.top+50) + (40*height); //블록 y좌표
   Block[i].bottom = (Block[i].top)+40; //블록 높이(블록 시작 위치에서 +하는 수치 만큼)
   Block[i].brake = FALSE;
   width++; //블록 5열로 맞추기 위한 카운트 변수 증가
 }break;

 default : //스테이지 2이상 블록 배치

  for(i = 0 ,height = 1, width =1; i < nBlock; i++){
    //이미지 시작 좌표 + (블록 가로 사이즈 * 블록 개수)

   //블록 다음행으로 개행, 1열 부터 다시 시작
   if(i%5 == 0) {height++; width = 1; }
   Block[i].left = ((cl.right/2) - (80*4)) + (80*width); //블록 x 좌표
   Block[i].right = (Block[i].left)+50; //블록 길이 (블록 시작 위치에서 + 하는 수치 만큼)
   Block[i].top = (cl.top+50) + (40*height); //블록 y좌표
   Block[i].bottom = (Block[i].top)+40; //블록 높이(블록 시작 위치에서 +하는 수치 만큼)
   Block[i].brake = FALSE;
   width++; //블록 5열로 맞추기 위한 카운트 변수 증가
  }
  break;
 }
```

### 충돌 체크

---

충돌 체크를 위해 다음과 같이 5개의 변수를 사용한다.

```c
static int nMove_X,nMove_Y; // 공의 이동 크기 및 방향 변화 값
static RECT rt,cl; // 공의 좌표값 , 클라이언트 영역
static POINT point;//마우스 컨트롤 바 좌표
```

충돌 체크는 아래와 같이 for문을 통해 루프를 돌며 배열로 잡혀 있는 모든 블록들을 하나 하나 방문하여 공의 좌표와 블록의 좌표가 겹쳐지는지 일일이 확인하는 방식으로 구현 되어 있다.
 
 ```c
 for(int i =0;i<nBlock;i++)
 {
  if(((Block[i].left-10 <= rt.left) && (Block[i].right+10 >= rt.right))
            &&//공이 블록 영역안에 들어 왔을때
           //(옆의 수치는 체크 영역 확장을 위해 더한 값)
   ((Block[i].top-10 <= rt.top) && (Block[i].bottom+10 >= rt.bottom))
           &&
        (Block[i].brake == FALSE)) {
   if((Block[i].top-10 <= rt.bottom) && (Block[i].top+20 >= rt.bottom))//블록 위에서 충돌    
   nMove_Y = (rand()%5+10)  * -1;
   if((Block[i].bottom-20 <= rt.top) && (Block[i].bottom+10 >= rt.top))//블록 아래서 충돌    
   nMove_Y = (rand()%5+10)  * 1;
   if((Block[i].left -15 <= rt.right) && (Block[i].left+20 >= rt.right))//블록 좌에서 충돌    
   nMove_X = (rand()%5+5)  * -1;
   if((Block[i].right-20  <= rt.left) && (Block[i].right+15 >= rt.left))//블록 우에서 충돌    
   nMove_X = (rand()%5+5)  * 1;

   Block[i].brake = TRUE; //벽돌 부서짐
   clear++;    //벽돌 부순 개수
   score += 150; // 스코어 기록
 
  }
 }
 ```